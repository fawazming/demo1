<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bulk SMS JSON Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="h-full flex items-center justify-center p-6">
  <div class="max-w-4xl w-full bg-white rounded-lg shadow p-6 space-y-6">
    <h1 class="text-2xl font-bold text-gray-800">Bulk SMS JSON Generator</h1>

    <div>
      <label for="unstructured" class="block font-semibold mb-1">Unstructured Data (one entry per line)</label>
      <textarea id="unstructured" rows="8" placeholder="e.g.
John Doe, 08108097322, Class A
Jane Smith, 07061811568, Class B
" class="w-full rounded border border-gray-300 p-3 resize-y focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
      <p class="mt-1 text-sm text-gray-500">Include phone number and other info (name, class, etc.) separated by commas or spaces.</p>
    </div>

    <div class="flex gap-2">
      <button id="parseBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition">Parse Data</button>
      <button id="generateBtn" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700 transition">Generate SMS JSON</button>
    </div>

    <div id="structuredSection" class="hidden">
      <label for="structured" class="block font-semibold mb-1">Structured Data (Parsed JSON)</label>
      <textarea id="structured" rows="6" class="w-full rounded border border-gray-300 p-3 font-mono text-sm bg-gray-100 resize-y"></textarea>
      <p class="mt-1 text-sm text-gray-500">Structured data extracted from unstructured input. Review and edit if needed.</p>
    </div>

    <div>
      <label for="message" class="block font-semibold mb-1">Message Template</label>
      <textarea id="message" rows="4" placeholder="e.g. Hello {name}, your class is {class}." class="w-full rounded border border-gray-300 p-3 resize-y focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
      <p class="mt-1 text-sm text-gray-500">Use placeholders like <code>{name}</code>, <code>{class}</code> to be replaced from structured data.</p>
    </div>

    <div>
      <label for="output" class="block font-semibold mb-1">Output JSON (Bulk SMS Format)</label>
      <textarea id="output" rows="10" readonly class="w-full rounded border border-gray-300 p-3 font-mono text-sm bg-gray-100 resize-y"></textarea>
    </div>
  </div>

  <script>
    // Store parsed data globally
    let parsedData = [];

    // Utility: Try to parse phone number from tokens (simple heuristic: digits only, length 7-15)
    function extractPhone(tokens) {
      for (const t of tokens) {
        const cleaned = t.replace(/[^\d]/g, '');
        if (cleaned.length >= 7 && cleaned.length <= 15) return cleaned;
      }
      return null;
    }

    // Parse a single line of unstructured data into an object with keys: phone, name, class, etc.
    function parseLine(line) {
      if (!line.trim()) return null;
      // Split by comma first, if no comma, split by spaces
      let parts = line.includes(',') ? line.split(',') : line.split(/\s+/);
      parts = parts.map(p => p.trim()).filter(p => p.length > 0);

      // Extract phone
      const phone = extractPhone(parts);
      if (!phone) return null;

      // Remove phone token from parts
      const partsWithoutPhone = parts.filter(p => p.replace(/[^\d]/g, '') !== phone);

      // Try to find name and class
      let nameTokens = [];
      let classToken = null;

      for (const p of partsWithoutPhone) {
        if (/class/i.test(p)) {
          classToken = p.toLowerCase().replace('class', '').trim();
        } else if (/[a-zA-Z]/.test(p)) {
          nameTokens.push(p);
        } else if (p) {
          // If it's not a word, it might be class without "class" prefix
          classToken = p;
        }
      }

      // If no explicit class token but more than one token in partsWithoutPhone, assume last token is class
      if (!classToken && nameTokens.length > 1) {
        classToken = nameTokens.pop();
      }

      const name = nameTokens.join(' ') || null;
      const className = classToken || null;

      return { 
        phone, 
        name: name || 'Unknown', 
        class: className || 'N/A',
        original: line 
      };
    }

    // Parse all unstructured data into structured format
    function parseUnstructuredData() {
      const unstructuredText = document.getElementById('unstructured').value;
      const structuredEl = document.getElementById('structured');
      const structuredSection = document.getElementById('structuredSection');
      
      if (!unstructuredText.trim()) {
        structuredEl.value = '// No data to parse';
        structuredSection.classList.remove('hidden');
        return [];
      }

      const lines = unstructuredText.split('\n');
      const parsed = [];

      for (const line of lines) {
        const data = parseLine(line);
        if (data) {
          parsed.push(data);
        }
      }

      // Update structured data textarea
      structuredEl.value = JSON.stringify(parsed, null, 2);
      structuredSection.classList.remove('hidden');
      
      return parsed;
    }

    // Replace placeholders in message template with data object values
    function fillTemplate(template, data) {
      return template.replace(/\{(\w+)\}/g, (_, key) => {
        return data[key] ?? `{${key}}`;
      });
    }

    // Parse button handler
    document.getElementById('parseBtn').addEventListener('click', () => {
      parsedData = parseUnstructuredData();
    });

    // Auto-parse when unstructured data changes
    document.getElementById('unstructured').addEventListener('input', () => {
      // Clear structured data if unstructured data is empty
      if (!document.getElementById('unstructured').value.trim()) {
        document.getElementById('structured').value = '';
        document.getElementById('structuredSection').classList.add('hidden');
        parsedData = [];
      }
    });

    // Generate button handler
    document.getElementById('generateBtn').addEventListener('click', () => {
      const messageTemplate = document.getElementById('message').value.trim();
      const outputEl = document.getElementById('output');

      // If parsedData is empty, try to parse first
      if (parsedData.length === 0) {
        parsedData = parseUnstructuredData();
      }

      if (parsedData.length === 0) {
        outputEl.value = '// Please enter and parse valid data first.';
        return;
      }

      if (!messageTemplate) {
        outputEl.value = '// Please enter a message template.';
        return;
      }

      const msgArray = parsedData.map(data => {
        return {
          phone: data.phone,
          message: fillTemplate(messageTemplate, data)
        };
      });

      const result = { msg: msgArray };
      outputEl.value = JSON.stringify(result, null, 2);
    });

    // Allow manual editing of structured data with validation
    document.getElementById('structured').addEventListener('input', function() {
      try {
        const editedData = JSON.parse(this.value);
        if (Array.isArray(editedData)) {
          parsedData = editedData;
        }
      } catch (e) {
        // Invalid JSON, keep previous parsed data
      }
    });
  </script>
</body>
</html>

